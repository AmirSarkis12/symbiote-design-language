// Media query breakpoints
    // Propigates up breakpoints e.g.: media-breakpoint-up(sm) -> sm breakpoint (inclusive) and up
    @mixin media-breakpoint-up($breakpoint) {
        @if($breakpoint == "xs") {
            @media (min-width: $xs-breakpoint) {
                @content;
            }
        }

        @if( $breakpoint == "sm" ) {
            @media (min-width: $sm-breakpoint) {
                @content;
            }
        }

        @if( $breakpoint == "md" ) {
            @media (min-width: $md-breakpoint) {
                @content;
            }
        }

        @if( $breakpoint == "lg" ) {
            @media (min-width: $lg-breakpoint) {
                @content;
            }
        }
    }

    // Propigates down breakpoints e.g.: media-breakpoint-down(sm) -> sm breakpoint (exclusive) and down
    @mixin media-breakpoint-down($breakpoint) {
        @if( $breakpoint == "sm" ) {
            @media (max-width: $sm-breakpoint - 1) {
                @content;
            }
        }

        @if( $breakpoint == "md" ) {
            @media (max-width: $md-breakpoint - 1) {
                @content;
            }
        }

        @if( $breakpoint == "lg" ) {
            @media (max-width: $lg-breakpoint - 1) {
                @content;
            }
        }
    }

    // Non-propigating breakpoint e.g.: media-breakpoint(sm) -> only within the bounds of the sm breakpoint
    @mixin media-breakpoint-only($breakpoint) {
        @if($breakpoint == "xs") {
            @media (max-width: $xs-breakpoint - 1) {
                @content;
            }
        }

        @if( $breakpoint == "sm" ) {
            @media (min-width: $sm-breakpoint) and (max-width: $md-breakpoint - 1) {
                @content;
            }
        }

        @if( $breakpoint == "md" ) {
            @media (min-width: $md-breakpoint) and (max-width: $lg-breakpoint - 1) {
                @content;
            }
        }

        @if( $breakpoint == "lg" ) {
            @media (min-width: $lg-breakpoint) {
                @content;
            }
        }
    }

// Clearfix - for clearing floats
@mixin clearfix() {
	&:before,
	&:after {
		content: " ";
		display: table;
	}

	&:after {
		clear: both;
	}
}

// Hides an element from the screen but not a screen reader
@mixin sr-only() {
	position: absolute;
	width: 1px;
	height: 1px;
	padding: 0;
	margin: -1px;
	overflow: hidden;
	clip: rect( 0, 0, 0, 0 );
	border: 0;
}

// Cross browser compatible opacity style
@mixin opacity($opacity) {
  opacity: $opacity;
  // IE8 filter
  $opacity-ie: ($opacity * 100);
  filter: #{alpha(opacity=$opacity-ie)};
}

// Provides a smooth transition effect for when elements have a styling augmentation
@mixin transition() {
    transition: all 0.2s ease-in-out;
}

// Darkens the background color of any element when hovered
@mixin darken-on-hover($color) {
    background-color: darken($color, 10%);
}

// Lightens the background color of any element when hovered
@mixin lighten-on-hover($color) {
    background-color: Lightens($color, 10%);
}

// Animated underline
@mixin animated-underline($color) {
    &:before,
    &:after {
        content: '';
        position: absolute;
        bottom: -0.25rem;
        left: 0; right: 0;
        height: 2px;
        background-color: $color
    }

    &:before {
        opacity: 0;
        transform: translateY(0.25rem);
        transition: transform 0s cubic-bezier(0.175, 0.885, 0.320, 1.275), opacity 0s;
    }

    &:after {
        opacity: 0;
        transform: translateY(0.25rem);

    }

    &:hover,
    &:focus {
        &:before,
        &:after {
            opacity: 1;
            transform: translateY(0);
        }
        &:before {
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.320, 1.275), opacity 0.3s;
        }
        &:after {
            transition: transform 0s 0.3s cubic-bezier(0.175, 0.885, 0.320, 1.275), opacity 0s 0.3s;
        }
    }
}


// General use drop shadow
@mixin general-shadow() {
    box-shadow: 0 1px 4px rgba(0,0,0,.15);
}

// Card specific shadows
    @mixin card-shadow() {
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
    }

    @mixin card-shadow-image() {
        box-shadow: 0 5px 30px 10px rgba($black, 0.3);
    }

    @mixin full-image-card-shadow() {
        box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2), 0 15px 12px rgba(0, 0, 0, 0.2), inset 0px -317px 50px -93px rgba(0, 0, 0, 0.33);
    }


// Grid specific mixins below
    // Iterates through all 12 columns to calculate the correct amount of left and right padding for each of the classes.
    @mixin make-grid-columns( $i: 1, $list: ".col-#{ $i }, .col-xs-#{ $i }, .col-sm-#{ $i }, .col-md-#{ $i }, .col-lg-#{ $i }" ) {
        @for $i from ( 1 + 1 ) through 12 {
            $list: "#{ $list }, .col-#{ $i }, .col-xs-#{ $i }, .col-sm-#{ $i }, .col-md-#{ $i }, .col-lg-#{ $i }";
        }

        #{ $list } {
            box-sizing: border-box;
            position: relative;
            min-height: 1px;
            padding-left:  ceil( ( $grid-gutter-width / 2 ) );
            padding-right: floor( ( $grid-gutter-width / 2 ) );
        }
    }

    // Iterates through the columns to create a new list and then sets the float.
    @mixin float-grid-columns( $class, $i: 1, $list: ".col-#{ $i }, .col-#{ $class }-#{ $i }" ) {
        @for $i from ( 1 + 1 ) through 12 {
            $list: "#{ $list }, .col-#{ $i }, .col-#{ $class }-#{ $i }";

        }

        #{ $list } {
            float: left;
        }
    }

    // Calculates the correct widths as a percentage based on the column count, column breakpoint class, and type (pull or offset).
    @mixin grid-calc-grid-column( $index, $class, $type ) {
        @if ( $type == width ) and ( $index > 0 ) {
            .col-#{ $class }-#{ $index } {
                width: percentage( ( $index / 12 ) );
			}

			.col-#{ $index } {
                width: percentage( ( $index / 12 ) );
            }
        }

        @if ( $type == push ) and ( $index > 0 ) {
            .col-#{ $class }-push-#{ $index } {
                left: percentage( ( $index / 12 ) );
            }
        }

        @if ( $type == push ) and ( $index == 0 ) {
            .col-#{ $class }-push-0 {
                left: auto;
            }
        }

        @if ($type == pull) and ( $index > 0 ) {
            .col-#{ $class }-pull-#{ $index } {
                right: percentage( ( $index / 12 ) );
            }
        }

        @if ($type == pull) and ( $index == 0 ) {
            .col-#{ $class }-pull-0 {
                right: auto;
            }
        }

        @if ($type == offset) {
            .col-#{ $class }-offset-#{ $index } {
                margin-left: percentage( ( $index / 12 ) );
            }
        }
    }

    // Calls the above mixins and combines them.
    @mixin loop-grid-columns( $columns, $class, $type ) {
        @for $i from 0 through $columns {
            @include grid-calc-grid-column( $i, $class, $type );
        }
    }

    // Finally, we create the grid and all the necessary classes.
    @mixin make-grid( $class ) {
        @include float-grid-columns( $class );
        @include loop-grid-columns( 12, $class, width );
        @include loop-grid-columns( 12, $class, pull );
        @include loop-grid-columns( 12, $class, push );
        @include loop-grid-columns( 12, $class, offset );
    }